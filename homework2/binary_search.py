# Бинарный поиск
#
# 1. Находится средний элемент последовательности.
# Первый и последний элементы связываются с переменными, а средний вычисляется.
# 2. Средний элемент сравнивается с искомым значение.
# В зависимости от того, больше оно или меньше среднего элемента,
# Дальнейший поиск будет происходить
# Лишь в левой или правой половинах массива.
# Если значение среднего элемента окажется равным искомому, то поиск завершен.
# 3. Одна из границ исследуемой последовательности становится равной
# Предыдущему или последующему среднему элементу из п.2.
# 4. Снова находится средний элемент, теперь уже в «выбранной» половине.
# Описанный выше алгоритм повторяется уже для данной последовательности.
#
massive = [-23, -5, 2, 3, 3, 4, 8, 32, 43, 54, 83]
searched_element = -23
left_border = 0
rigth_border = len(massive) - 1
mid_elem = int(rigth_border / 2)

while massive[mid_elem] != searched_element and left_border < rigth_border:
    if searched_element > massive[mid_elem]:
        left_border = mid_elem + 1
    else:
        rigth_border = mid_elem - 1
    mid_elem = int((left_border + rigth_border) / 2)

if left_border > rigth_border:
    print('Элемент нет в массиве')
else:
    print('Индекс элемента: ', mid_elem)

# Сложность такого поиска O(log(N))
# Так как каждый раз уменьшая диапозон поиска
# Мы делим искомый отрезок пополам.
